from django.shortcuts import render
from chatbot.utils_retriever import process_json_documents
from chatbot.utils_RAG import generate_response
from chatbot.serializers import ChatbotSerializer
from chatbot.models import Chatbot
from .utils import fetch_annonces
from rest_framework.decorators import api_view, permission_classes
from django.http import JsonResponse
from rest_framework.permissions import AllowAny
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
@api_view(['GET'])
@permission_classes([AllowAny]) 
def rag_index(request):

    annonces = fetch_annonces()
    # print({"annonces":annonces})
    vectors= process_json_documents(annonces)
    return JsonResponse({
        "status": "success",
        "indexed_documents": len(vectors)
    })
question_param = openapi.Schema(
    type=openapi.TYPE_OBJECT,
    properties={
        'question': openapi.Schema(type=openapi.TYPE_STRING, description='The user question to ask the RAG chatbot'),
        "user": openapi.Schema(type=openapi.TYPE_INTEGER, description='USER ID '),
    },
    required=['question']
)

# Define response schema
answer_response = openapi.Schema(
    type=openapi.TYPE_OBJECT,
    properties={
        'question': openapi.Schema(type=openapi.TYPE_STRING, description='Original user question'),
        'answer': openapi.Schema(type=openapi.TYPE_STRING, description='Answer generated by the RAG system'),
        "user": openapi.Schema(type=openapi.TYPE_INTEGER, description='USER ID '),
        'results': openapi.Schema(
            type=openapi.TYPE_ARRAY,
            items=openapi.Items(type=openapi.TYPE_OBJECT),
            description='List of matched documents with metadata'
        )
    }
)

@swagger_auto_schema(
    method='post',
    request_body=question_param,
    responses={200: answer_response},
    operation_description="Ask a question to the RAG chatbot and get answer + matched documents"
)
@api_view(['POST'])
@permission_classes([AllowAny])  
def rag_query(request):
    question = request.data.get("question", "").strip().lower()
    user=request.data.get("user", "")
    print({"user":user})
    answer=generate_response(question)
    data={
        "question": question,
        "answer": answer,
        "created_by":user
    }
    serializer_chatbot=ChatbotSerializer(data=data)
    if serializer_chatbot.is_valid():
        serializer_chatbot.save()
    return JsonResponse({
        "question": question,
        "answer": answer,
    })

@api_view(['GET'])
@permission_classes([])  
def get_messages(request,id):
    list_messges=[]
    if Chatbot.objects.filter(created_by=id).exists():
        res=Chatbot.objects.filter(created_by=id)
        for obj in res:
            obj_dict={
                "id":obj.pk,
                "question":obj.question,
                "answer":obj.answer,
                "created_by":obj.created_by,
                "created_at":obj.created_at,
            }
            list_messges.append(obj_dict)
    return JsonResponse({"messages":list_messges})

@api_view(['PUT'])
@permission_classes([AllowAny])
def update_message(request, pk):
    try:
        chatbot = Chatbot.objects.get(pk=pk)
    except Chatbot.DoesNotExist:
        return JsonResponse({"error": "Not found"}, status=404)
    question = request.data.get("question", "").strip().lower()
    answer=generate_response(question)
    chatbot.question=question
    chatbot.answer=answer
    chatbot.save()
    return JsonResponse({
        "question": question,
        "answer": answer,
    })

@api_view(['DELETE'])
@permission_classes([AllowAny])
def delete_message(request, pk):
    Chatbot.objects.filter(pk=pk).delete()
    return JsonResponse({"status": "deleted"})
